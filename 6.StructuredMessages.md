# Structured Messages (questions)

![](wiki-images/StructuredMessage.png)

Secured, encrypted communication between different parried clients can be established by following next steps: 

### 1-2. Message received with predefined answers or with response attribute name, so user can choose from the list of the predefined answers or can enter his own answer manually. 

	UI for presenting answers to user or form field(s) for answer manually needs to be added (it's not in the mobile SDK yet).
	
	> iOS: decoding message payload and deserializing connection 

```ObjC

NSMutableDictionary *decryptedPayload = [NSJSONSerialization JSONObjectWithData:[msg[@"decryptedPayload"] dataUsingEncoding:NSUTF8StringEncoding] options:NSJSONReadingMutableContainers error:&error];

[[sdkAPI] connectionDeserialize:serializedConnection completion:^(NSError *error, NSInteger connectionHandle) {
	// handle errors
	NSMutableDictionary *decryptedPayloadMsg = [NSJSONSerialization JSONObjectWithData:[decryptedPayload[@"@msg"] dataUsingEncoding:NSUTF8StringEncoding] options:NSJSONReadingMutableContainers error:&error];
	
}
```


	
### 3. After receiving message object, we need to ask user to select answer or enter it manually: 

> in this example, user selected first object from array of answers: 

```ObjC
NSString *data = decryptedPayloadMsg[@"valid_responses"][0][@"nonce"];
```

### 4. Let's encode selected answer to base64 format before we send it back to agency

```ObjC
NSData *plainData = [answerString dataUsingEncoding:NSUTF8StringEncoding];
NSString *encodedAnswer = [plainData base64EncodedStringWithOptions: 0];
```

### 5. Send encoded answer back to server using method `connectionSendData`:

```ObjC
[[sdkAPI] connectionSignData:(int)connectionHandle withData: dataToSign withCompletion:^(NSError *error, NSData *signature_raw, vcx_u32_t signature_len) {
	// handle errors
	NSData *dataToSign = [encodedAnswer dataUsingEncoding: NSUTF8StringEncoding];
}
```

### 6. Verifying connection signature

```ObjC
[[sdkAPI] connectionVerifySignature: (int)connectionHandle withData:dataToSign withSignatureData: signature_raw withCompletion:^(NSError *error, vcx_bool_t valid) {
	// handle errors
}
```

### 7. Populate answer object and send answer message back

```ObjC
NSString *signedData = [NSString stringWithUTF8String: [dataToSign bytes]];

NSDictionary *responseSig = @{
	@"signature" : signature,
	@"sig_data" : signedData,
	@"timestamp" : [timestamp string in seconds]
};
                                    
NSDictionary *messageToSign = @{
	@"@type" : @"did:sov:BzCbsNYhMrjHiqZDTUASHg;spec/committedanswer/1.0/answer",
	@"response.@sig" : responseSig
};

NSDictionary *messageOptions = @{
	@"msg_type" : @"Answer",
	@"msg_title" : @"Peer sent answer",
	@"ref_msg_id" : messageId
};
NSString *jsonString = [convert messageToSign to JsonString];
NSString *jsonMessageOptions = [Utilities messageOptions to JsonString];

```


### 8. Send message 

```ObjC
[[sdkAPI] connectionSendMessage:(int)connectionHandle withMessage:jsonString withSendMessageOptions:jsonMessageOptions withCompletion:^(NSError *error, NSString *msg_id) {
	// handle errors
}
```


## Full flow - javascript example


1. Call connectionSignData(connectionHandle, data, base64EncodingOption, encodeBeforeSigning )

	PARAMS:
```javascript 
	connectionHandle: 'from connection sending question'
	data: 'answer.nonce, would get this when you users selects answer from answers from your secureMessage'
	base64EncodingOption: 'defaults to 'NO_WRAP' in connect.me another option of "URL_SAFE"' 
	encodeBeforeSigning: 'defaults to true in connect.me'
```
    
RETURNS
```javascript    
	{ data, signature } //  to be used in connectionSendMessage
```


2. Call connectionSendMessage(connectionHandle, withMessage )
	PARAMS
	
```javascript
	connectionHandle: from connection sending question
	withMessage: JSON.stringify(
		'@type': 'did:sov:BzCbsNYhMrjHiqZDTUASHg;spec/committedanswer/1.0/answer',
	 	'response.@sig': {
		   	signature: signature, // signature from connectionSignData
		  	sig_data: data, // data from connectionSignData
		   	timestamp: moment().format(),
	  	}
	})

	endMessageOptions: JSON.stringify({
	    msg_type: 'Answer',
	  	msg_title: 'Peer Sent Answer',
	 	ref_msg_id: uid || null, // get uid from question.payload.uid (from secure message)
	})
```

```javascript
	// javascript example
    async getMessages(pwDID) {
    
    }

```
