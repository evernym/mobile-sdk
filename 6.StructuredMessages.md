# Structured Messages (questions)

- [Structured Messages (questions)](#structured-messages-questions)
	- [1. Message received](#1-message-received)
	- [2. Decoding message payload and deserializing connection](#2-decoding-message-payload-and-deserializing-connection)
		- [iOS](#ios)
		- [Android](#android)
	- [3. Gather user answer](#3-gather-user-answer)
		- [iOS](#ios-1)
	- [4. Encoding answer(s)](#4-encoding-answers)
		- [iOS](#ios-2)
	- [5. Send encoded answer back to server using method `connectionSendData`:](#5-send-encoded-answer-back-to-server-using-method-connectionsenddata)
		- [iOS](#ios-3)
		- [Android](#android-1)
	- [6. Verifying connection signature](#6-verifying-connection-signature)
		- [iOS](#ios-4)
		- [Android](#android-2)
	- [7. Populate answer object and send answer message back](#7-populate-answer-object-and-send-answer-message-back)
		- [iOS](#ios-5)
		- [Android](#android-3)
	- [8. Send message](#8-send-message)
		- [iOS](#ios-6)
		- [Android](#android-4)
	- [Complete flow - javascript example](#complete-flow---javascript-example)
  

![](wiki-images/StructuredMessage.png)

--- 

Secured, encrypted communication between different parried clients can be established by following next steps: 

## 1. Message received
> Message is received with predefined answers or with response attribute name, so user can choose from the list of the predefined answers or can enter his own answer manually. 

	UI for presenting answers to user or form field(s) for answer manually needs to be added (it's not the part of the mobile SDK yet).


--- 
	
## 2. Decoding message payload and deserializing connection 

### iOS
```ObjC

NSMutableDictionary *decryptedPayload = [NSJSONSerialization JSONObjectWithData: [msg[@"decryptedPayload"] dataUsingEncoding: NSUTF8StringEncoding] options: NSJSONReadingMutableContainers error: &error];

[[sdkAPI] connectionDeserialize: serializedConnection completion:^(NSError *error, NSInteger connectionHandle) {
	// handle errors
	NSMutableDictionary *decryptedPayloadMsg = [NSJSONSerialization JSONObjectWithData:[decryptedPayload[@"@msg"] dataUsingEncoding:NSUTF8StringEncoding] options:NSJSONReadingMutableContainers error:&error];
	
}
```

### Android
```java
ConnectionApi.connectionDeserialize(serializedConnection)
    .exceptionally((t) -> {
        // hadle error response
        return -1;
    }).thenAccept(result -> {
        if (result != -1) {
            // hadle successful response
        }
    });
```

---
	
## 3. Gather user answer 

After receiving message object, we need to ask user to select answer or enter it manually: 

> in this example, user selected first object from array of answers: 

### iOS
```ObjC
NSMutableDictionary *decryptedPayload = [NSJSONSerialization JSONObjectWithData: [msg[@"decryptedPayload"] dataUsingEncoding: NSUTF8StringEncoding] options:NSJSONReadingMutableContainers error:&error];
NSMutableDictionary *decryptedPayloadMsg = [NSJSONSerialization JSONObjectWithData: [decryptedPayload[@"@msg"] dataUsingEncoding: NSUTF8StringEncoding] options: NSJSONReadingMutableContainers error: &error];
NSString *data = decryptedPayloadMsg[@"valid_responses"][0][@"nonce"];
```

---

## 4. Encoding answer(s)

Let's encode selected answer to base64 format before we send it back to agency

### iOS
```ObjC
NSData *plainData = [answerString dataUsingEncoding: NSUTF8StringEncoding];
NSString *encodedAnswer = [plainData base64EncodedStringWithOptions: 0];
```

---

## 5. Send encoded answer back to server using method `connectionSendData`:

### iOS
```ObjC
[[sdkAPI] connectionSignData: (int)connectionHandle 
	withData: dataToSign
	withCompletion: ^(NSError *error, NSData *signature_raw, vcx_u32_t signature_len) {
	// handle errors
	NSData *dataToSign = [encodedAnswer dataUsingEncoding: NSUTF8StringEncoding];
}
```

### Android
```java
ConnectionApi.connectionSignData(
	connectionHandle, 
	dataToSign, 
	dataToSign.length
).exceptionally((t) -> {
    
	return null;
}).thenAccept(result -> {
	try {
		if (result != null) {
			WritableMap signResponse = Arguments.createMap();
			signResponse.putString("data", new String(dataToSign));
			signResponse.putString("signature", Base64.encodeToString(result, base64EncodeOption));
			// handle successful result 
		} else {
			promise.reject("NULL-VALUE", "Null value was received as result from wrapper");
		}
	} catch(Exception e) {
		// it might happen that we get value of result to not be a byte array
		// or we might get empty byte array
		// in all those case outer try...catch will not work because this inside callback of a Future
		// so we need to handle the case for Future callback inside that callback
		promise.reject(e);
	}
});
```

--- 

## 6. Verifying connection signature

### iOS
```ObjC
[[sdkAPI] connectionVerifySignature: (int)connectionHandle 		
	withData: dataToSign
	withSignatureData: signature_raw 
	withCompletion: ^(NSError *error, vcx_bool_t valid) {
	// handle errors
}
```

### Android
```java
ConnectionApi.connectionVerifySignature(
	connectionHandle,
	dataToVerify,
	dataToVerify.length,
	signatureToVerify,
	signatureToVerify.length
).exceptionally((t) -> {
        // handle error result	        
		return null;
	}).thenAccept(result -> {
		// handle successful result	
	});
```

--- 

## 7. Populate answer object and send answer message back

### iOS
```ObjC
NSString *signedData = [NSString stringWithUTF8String: [dataToSign bytes]];

NSDictionary *responseSig = @{
	@"signature" : signature,
	@"sig_data" : signedData,
	@"timestamp" : [timestamp string in seconds]
};
                                    
NSDictionary *messageToSign = @{
	@"@type" : @"did:sov:BzCbsNYhMrjHiqZDTUASHg;spec/committedanswer/1.0/answer",
	@"response.@sig" : responseSig
};

NSDictionary *messageOptions = @{
	@"msg_type" : @"Answer",
	@"msg_title" : @"Peer sent answer",
	@"ref_msg_id" : messageId
};
NSString *jsonString = [convert messageToSign to JsonString];
NSString *jsonMessageOptions = [Utilities messageOptions to JsonString];

```

### Android
```java

```


---

## 8. Send message 

### iOS
```ObjC
[[sdkAPI] connectionSendMessage:(int)connectionHandle withMessage:jsonString withSendMessageOptions:jsonMessageOptions withCompletion:^(NSError *error, NSString *msg_id) {
	// handle errors
}
```

### Android
```java
ConnectionApi.connectionSendMessage(connectionHandle, message, sendMessageOptions)
	.exceptionally((t) -> {
    	// handle error result
			return null;
	}).thenAccept(result -> {
		// handle successful result
	});
```
 
---
## Complete flow - javascript example


1. Call connectionSignData(connectionHandle, data, base64EncodingOption, encodeBeforeSigning )

	PARAMS:
```javascript 
	connectionHandle: 'from connection sending question'
	data: 'answer.nonce, would get this when you users selects answer from answers from your secureMessage'
	base64EncodingOption: 'defaults to 'NO_WRAP' in connect.me another option of "URL_SAFE"' 
	encodeBeforeSigning: 'defaults to true in connect.me'
```
    
RETURNS
```javascript    
	{ data, signature } //  to be used in connectionSendMessage
```

2. Call connectionSendMessage(connectionHandle, withMessage)
	PARAMS
	
```javascript
	connectionHandle: from connection sending question
	withMessage: JSON.stringify(
		'@type': 'did:sov:BzCbsNYhMrjHiqZDTUASHg;spec/committedanswer/1.0/answer',
	 	'response.@sig': {
		   	signature: signature, // signature from connectionSignData
		  	sig_data: data, // data from connectionSignData
		   	timestamp: moment().format(),
	  	}
	})

	endMessageOptions: JSON.stringify({
	    msg_type: 'Answer',
	  	msg_title: 'Peer Sent Answer',
	 	ref_msg_id: uid || null, // get uid from question.payload.uid (from secure message)
	})
```

```javascript
	// javascript example
    async getMessages(pwDID) {
    
    }

```
