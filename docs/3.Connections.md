# 3. Connections

To set up a connection between the Inviter (server) and the Invitee (client) the process must complete these steps:

  1. Check type of invitation: [aries connection](#aries-connection-invitation) and [aries out-of-band](#aries-out-of-band-invitation) formats are supported.
  2. Ensure that connection has not been established yet.
  3. Depending on the invitation type call corresponding methods.
  4. Await Connection is completed.

To accept a connection invitation and form a new connection, mobile SDK generates a new unique DID and associated keypair. The public key is then included in the response to the Inviter. 

This exchange results in both parties recording the other's public key, thereby forming a unique pairwise encryption channel. Mobile SDK can form an unlimited number of connections in this way.

> **NOTE:** library should be initialized before using connections API. See [initialization documentation](2.Initialization.md)

## Establish connection

Aries Connection protocol consists of several messages exchange:
* Inviter prepares `Connection Invitation` message
* Invitee sends `Connection Request` message to Inviter
* Inviter handles message and sends `Connection Response` message to Invitee
* Invitee handles message and sends `Connection Ack` message (if requested) to Inviter

### 1. Identify type of received invitation

### Aries Connection invitation

The value of `@type` field **must** end with `connections/1.0/invitation`.

#### Example:

```json
{
    "label": "Acme",
    "serviceEndpoint": "http://vas.evernym.com:80/agency/msg",
    "recipientKeys": [
        "9NR9NYh5z5HHu6nLHnQWXczUqRwrdoL4KBUWvo2fE6vj"
    ],
    "routingKeys": [
        "9NR9NYh5z5HHu6nLHnQWXczUqRwrdoL4KBUWvo2fE6vj",
        "3mo3P6XzDzBvuktCgDQarACzzeV7zxrSExnicpuH7t83"
    ],
    "profileUrl": "https://s3.us-east-2.amazonaws.com/public-demo-artifacts/demo-icons/cbACME.png",
    "@type": "did:sov:BzCbsNYhMrjHiqZDTUASHg;spec/connections/1.0/invitation",
    "@id": "467f6449-7d1f-4a9f-ada7-09d6444af083"
}
```

Invitation may optionally contain meta information describing the Inviter:
- `invite["label"]` - Name of the inviter
- `invite["profileUrl"]` - URL with inviter logo (optional)

More information about Aries Connection invitation and related protocol you can find [here](https://github.com/hyperledger/aries-rfcs/tree/master/features/0160-connection-protocol). 

### Aries Out-of-band invitation

The value of `@type` field **must** end with `/out-of-band/1.0/invitation`.

#### Example:

```json
{
  "@type": "https://didcomm.org/out-of-band/1.0/invitation",
  "@id": "9NR9NYh5z5HHu6nLHnQWXczUqRwrdoL4KBUWvo2fE6vj",
  "label": "Faber College",
  "goal_code": "issue-vc", // optional
  "goal": "To issue a Faber College Graduate credential",
  "handshake_protocols": [
      "https://didcomm.org/didexchange/1.0",
      "https://didcomm.org/connections/1.0"
      ],
  "request~attach": [
    // may be empty
    { 
        "@id": "request-0",
        "mime-type": "application/json",
        "data": {
            "json": "<json of protocol message>"
        }
    }
  ],
  "service": ["did:sov:LjgpST2rjsoxYegQDRm7EL"]
}
```

Invitation may optionally contain meta information describing the Inviter:
- `invite["label"]` - Name of the inviter
- `invite["profileUrl"]` - URL with inviter logo (optional)

More information about Aries Out-Of-Band invitation and related protocol you can find [here](https://github.com/hyperledger/aries-rfcs/tree/master/features/0434-outofband).

### URL invitation format

Both invitation types can also be represented in form of URL:

* Aries Connection invitation - https://<domain>/<path>?c_i=[Base-64 encoded invitation]
* Aries Out-Of-Band invitation - https://<domain>/<path>?oob=[Base-64 encoded invitation]

In this case, you need to decode Base-64 string first. The result value should match the formats we described above.

#### Example:

```
http://vas.evernym.com:80/agency/msg?c_i=eyJsYWJlbCI6IkFjbWUiLCJzZXJ2aWNlRW5kcG9pbnQiOiJodHRwOi8vdmFzLmV2ZXJueW0uY29tOjgwL2FnZW5jeS9tc2ciLCJyZWNpcGllbnRLZXlzIjpbIjNhVkhWZEFxZnBKSmVROG1mdm5UV0Y0MVpoYUxidVVLQXJ3UlVCRldlWjNRIl0sInJvdXRpbmdLZXlzIjpbIjNhVkhWZEFxZnBKSmVROG1mdm5UV0Y0MVpoYUxidVVLQXJ3UlVCRldlWjNRIiwiM21vM1A2WHpEekJ2dWt0Q2dEUWFyQUN6emVWN3p4clNFeG5pY3B1SDd0ODMiXSwicHJvZmlsZVVybCI6Imh0dHBzOi8vczMudXMtZWFzdC0yLmFtYXpvbmF3cy5jb20vcHVibGljLWRlbW8tYXJ0aWZhY3RzL2RlbW8taWNvbnMvY2JBQ01FLnBuZyIsIkB0eXBlIjoiZGlkOnNvdjpCekNic05ZaE1yakhpcVpEVFVBU0hnO3NwZWMvY29ubmVjdGlvbnMvMS4wL2ludml0YXRpb24iLCJAaWQiOiI4YWE1ZTZjOS1mZjZkLTQ0NDUtOWU1Ni1iNDU1MjQxZTVlZGIifQ==
```

### 2. Create Connection state object using received Invitation

Successful execution will return a connection handle.
This handle points to created Connection state object and should be used for later operations related to this connection.

#### iOS

* For `aries connection` invitation:

   ```objc
   [appDelegate.sdkApi connectionCreateWithInvite: invitationId
           inviteDetails: inviteDetails
           completion:^(NSError *error, NSInteger connectionHandle) {
               // ...
           }];
   ```

* For `aries out-of-band` invitation:

   ```objc
   [appDelegate.sdkApi connectionCreateWithOutofbandInvite: invitationId
           invite: inviteDetails
           completion:^(NSError *error, NSInteger connectionHandle) {
               // ...
           }];
   ```

#### Android

* For `aries connection` invitation:

   ```java
   int connectionHandle = ConnectionApi.vcxCreateConnectionWithInvite(invitationId, invitationDetails).get();
   ```

* For `aries out-of-band` invitation:

   ```java
   int connectionHandle = ConnectionApi.vcxCreateConnectionWithOutofbandInvite(invitationId, invitationDetails).get();
   ```

### 3. Check whether connection has been already established

The previous step only creates a Connection state object but not actually accept the invitation.
Before accepting a connection invitation you need to check that it has not been used yet.
In order to check does connection already exists, we need to retrieve invitations that were used during the creation of existing connections and compare them with the received invitation.

1. Extract original invitation for existing connections

   1. Deserialize connection

      #### iOS
       ```objC
       [appDelegate.sdkApi connectionDeserialize:serializedConnection
               completion:^(NSError *error, NSInteger connectionHandle) {
                   // ...
               }];
       ```

      #### Android
       ```java
       int connectionHandle = ConnectionApi.connectionDeserialize(serializedConnection).get();
       ```
   1. Get invitation 

      #### iOS
       ```objC
       [appDelegate.sdkApi getConnectionInviteDetails:connectionHandle
                                          abbreviated:FALSE
                                           completion:^(NSError *error, NSInteger connectionInvite) {
                                              // ...
                                          }];
       ```

      #### Android
       ```java
       String connectionInvite = ConnectionApi.connectionInviteDetails(handle, abbreviated).get();
       ```

1. Compare invitations - invitations match when one of the following fields is the same for both of them:

   * `@id` field (means exactly the same invitation)
   * `public_did` field (invitation from same Inviter)
   * `recipient_keys[0]` field (invitation from same Inviter)
    
1. If you find that connection already exists for the received invitation you would better reuse the existing connection rather than establish a new one.
You can read how to reuse existing connection in the [section](#reusing-existing-connections).
   
### 4.Accept connection invitation.

If you want to accept the invitation and established a connection you need to create Pairwise Cloud Agent and send Connection Request message.

   #### iOS
    ```objc
    [appDelegate.sdkApi connectionConnect: connectionHandle
                           connectionType: connType
            completion:^(NSError *error, NSInteger inviteDetails) {
                // ...
            }];
    ```

   #### Android
    ```java
    ConnectionApi.vcxConnectionConnect(connectionHandle, connType).get();
    ```

### 5. Await Connection is completed.

On the Invitee side the connection will be completed when `Connection Response` message received and processed.
After that, Connection state machine will be moved to the state `4` (`Accepted`). 

Call following code in loop until returned state is not equal `4` (`Accepted`). 
   
   ### iOS

    ```objc
    while(1) {
        [appDelegate.sdkApi connectionUpdateState:connectionHandle
            completion:^(NSError *error, NSInteger state) {
                    if (state == 4){
                        break;
                    }
        }
    }
    ```

   ### Android

    ```java
    int state = -1;
    while(state != 4){
        state = ConnectionApi.vcxConnectionUpdateState(connectionHandle).get();
    }
    ```

### 6. Serialize Connection object and store in the application storage

Once we get the Ð¡onnection completed we need to store it for future usages.

1. Serialize Connection object
   #### iOS
    ```objC
    [appDelegate.sdkApi connectionSerialize:connectionHandle
            completion:^(NSError *error, NSString *serializedConnection)) {
                // ...
            }];
    ```

   #### Android
    ```java
        String serializedConnection = ConnectionApi.connectionSerialize(connectionHandle).get();
    ``` 

2. Fetch Connection `pwDid`. This field will be unique among all established connections.
    This field will be also needed during the handling of messages received from the Cloud Agent (in order to associate messages with serialized connections).

    #### iOS
        ```objC
        [appDelegate.sdkApi connectionGetPwDid:connectionHandle
                completion:^(NSError *error, NSString *serializedConnection)) {
                    // ...
                }];
        ```
    
    #### Android
        ```java
            String pwDid = ConnectionApi.connectionGetPwDid(connectionHandle).get();
        ``` 

3. As MSDK doesn't persist state objects it is up to the developer regarding what data to store in the application storage. 
   On of the possible formats may match the following structure:
    ```
    {
        "pwDid" - string, // connection pairwise DID
        "serialized" - string, // serialized SDK object
   
        // metadata to show on the UI
        "name" - string, // inviter name
        "logo" - string, // inviter logo
   
        // optionally
        "invitation" - string // original invitation was used to establish the connection, 
                                It will simply check for already accepted invitations 
                                `1. Extract original invitation for existing connections` step will not be needed anymore
    }
    ```

4. Every time in the future you want to perform some operations using the created connection you first need to fetch Connection object from the storage and next deserialize SDK object from its serialized representation (receive a new handle).

5. Now your application should have a persistent collection of connection specific objects which:
    * must be used later for getting and sending messages.
    * can be used on the application UI to show the list of pending/established connections.

## Reusing Existing Connections

With adding more and more connections, its getting hard for user to remember which connections already established. There is potential that some of the new connections user tries to establish already exists in list of connections (e.g. QR code was scanned multiple types). In this case we should not create new connection and try to reuse existing one.

### Aries Connection invitation

A regular Aries connection protocol does not contain connection redirection steps.

### Aries Out-Of-Band Connection invitation

Aries RFCs provides [Out-of-Band](https://github.com/hyperledger/aries-rfcs/tree/master/features/0434-outofband) protocol describing the way of creating new connections and reusing of existing.

The steps need to be taken by the app depends on the format of received Out-of-Band invitation.

Bellow we will describe steps for a case when there is no action attached (`request~attach`) to the invitation.

If you want to get guidelines on how to handle all possible Out-of-Band invitation cases go to the [document](./Out-of-Band.md)

For this section we assume the following facts:
1. Connection matching to the provided invitation is already exists.
1. Out-of-Band invitation contains `handshake_protocols`
1. Out-of-Band invitation does not `request~attach` or it's an empty array.

1. Deserialize existing Connection state object

   #### iOS
    ```objC
    [appDelegate.sdkApi connectionDeserialize:serializedConnection
            completion:^(NSError *error, NSInteger connectionHandle) {
                // ...
            }];
    ```

   #### Android
    ```java
    int existingConnectionHandle = ConnectionApi.connectionDeserialize(serializedConnection).get();
    ```

1. Send Connection Reuse message

   #### iOS
    ```objC
    [appDelegate.sdkApi connectionSendReuse:existingConnectionHandle
            invite:newInvite
            withCompletion:^(NSError *error) {
                // ...
            }];
    ```

   #### Android
    ```java
     ConnectionApi.connectionSendReuse(existingConnectionHandle, newInvite).get();
    ```

1. Await for `handshake-reuse-accepted` message received for old Connection.

   See [messages documentation](MessagesFlow.md) for message download information.
   Pending messages with `handshake-reuse-accepted` type should be downloaded.

   Next, update message status as read. See [messages documentation](MessagesFlow.md) for message update information.

## Expected errors with establishing connection

### Connection already exists

It is expected use cases when user on mobile device tries to establish connection which already exists (user already connected before tries again). 
In that case, we don't need to reset connection (delete existing connection and create new connection with same pair). You can reuse existing connection.

You can find more details about this use case [here](#reusing-existing-connections).

## Next Step

Now your application is able to established connections with other parties.
You are ready to ready how to [receive verifiable credentials](4.Credentials.md).
