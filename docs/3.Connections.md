# 3. Connections

Connection is a communication channel between two parties.
During the connection establishing process, both parts exchange their public keys.
This exchange results in both parties recording the other's public key, thereby forming a unique pairwise encryption channel.
That keys will be used for messages encryption during later communications between parties.
Mobile SDK can form an unlimited number of connections in this way.

There are two roles in the connection establishing process: **Inviter** and **Invitee**.

* The Inviter is the party that initiates the connection protocol with an **Invitation** message and transfer it in some usual way (SMS, QR, etc.). [Verity SDK](https://github.com/evernym/verity-sdk) can be used as an **Inviter**.
* The Invitee is the party that accepts the invitation to establish the connection. **Mobile SDK** represents the **Invitee** party. Bellow in this document we will explain which steps need to be taken in order to accept a connection invitation on the **Invitee** side using Mobile SDK.

## Establishing connections

Aries Connection and Out-of-Band protocols consist of several messages exchange:
* Inviter prepares `Connection Invitation` message and shares it with an Invitee some ual way (SMS, QR, etc.)
* Invitee sends `Connection Request` message to Inviter
* Inviter handles `Connection Request` message and sends `Connection Response` message to Invitee
* Invitee handles `Connection Response` message and sends `Connection Ack` message (if requested) to Inviter

### Steps overview

In order to accept a `Connection Invitation` an Invitee (client) need to take the following steps:

1. Check type of invitation: [aries connection](#connection-invitation-example) and [aries out-of-band](#out-of-band-invitation-example) formats are supported.
2. Ensure that connection has not been established yet.
3. If there is no existing connection:\
   3.1. Depending on the invitation type call corresponding method to create SDK state object.
   3.2. Await Connection is completed.
4. If there is an existing connection:\
    4.1. Reuse existing connection.

> **NOTE:** The library should be initialized before forming a connection. See [initialization documentation](2.Initialization.md)

### 1. Identify the type of received invitation

### Aries Connection invitation

The value of `@type` field **must** end with `connections/1.0/invitation`.

#### Connection Invitation Example

```
{
    // type of the message
    "@type": "did:sov:BzCbsNYhMrjHiqZDTUASHg;spec/connections/1.0/invitation",
    // id of the message
    "@id": "467f6449-7d1f-4a9f-ada7-09d6444af083",
    // name of the Inviter
    "label": "Acme",
    // URL with the Inviter logo (Optional)
    "profileUrl": "https://s3.us-east-2.amazonaws.com/public-demo-artifacts/demo-icons/cbACME.png",
    // Endpoint of the Inviter Agnet
    "serviceEndpoint": "http://vas.evernym.com:80/agency/msg",
    // Public key of the Inviter to encrypt messages  
    "recipientKeys": [
        "9NR9NYh5z5HHu6nLHnQWXczUqRwrdoL4KBUWvo2fE6vj"
    ],
    // Keys defining the Inviter Agent (Optional)
    "routingKeys": [
        "9NR9NYh5z5HHu6nLHnQWXczUqRwrdoL4KBUWvo2fE6vj",
        "3mo3P6XzDzBvuktCgDQarACzzeV7zxrSExnicpuH7t83"
    ]
}
```

The following fields can be used to show the invitation on the UI:
- `invite["label"]` - Name of the inviter
- `invite["profileUrl"]` - URL with inviter logo (optional - maybe missed in the invitation)

More information about Aries Connection invitation and related protocol you can find [here](https://github.com/hyperledger/aries-rfcs/tree/master/features/0160-connection-protocol). 

### Aries Out-of-band invitation

The value of `@type` field **must** end with `/out-of-band/1.0/invitation`.

#### Out-of-band Invitation Example:

```
{
    // type of the message
    "@type": "https://didcomm.org/out-of-band/1.0/invitation",
    // id of the message
    "@id": "9NR9NYh5z5HHu6nLHnQWXczUqRwrdoL4KBUWvo2fE6vj",
    // name of the Inviter
    "label": "Faber College",
    // invitation goal code defined by the Inviter (Optional)
    "goal_code": "issue-vc",
    // a text defining the goal of the connection establishing (Optional)
    "goal": "To issue a Faber College Graduate credential",
    // Protocols can be used to establish a connection
    "handshake_protocols": [
        "https://didcomm.org/didexchange/1.0",
        "https://didcomm.org/connections/1.0"
    ],
    // An additional message attached to the invitation (Optional)
    "request~attach": [
      {
          "@id": "request-0",
          "mime-type": "application/json",
          "data": {
              "json": "<json of protocol message>"
          }
      }
    ],
    // Service of the Inviter Agent
    "service": [
        {
            "id": "#inline",
            "type": "did-communication",
            // Endpoint of the Inviter Agnet
            "serviceEndpoint": "http://vas.evernym.com:80/agency/msg",
            // Public key of the Inviter to encrypt messages  
            "recipientKeys": [
                "9NR9NYh5z5HHu6nLHnQWXczUqRwrdoL4KBUWvo2fE6vj"
            ],
            // Keys defining the Inviter Agent (Optional)
            "routingKeys": [
                "9NR9NYh5z5HHu6nLHnQWXczUqRwrdoL4KBUWvo2fE6vj",
                "3mo3P6XzDzBvuktCgDQarACzzeV7zxrSExnicpuH7t83"
            ]
        },
    ]
}
```

The following fields can be used to show the invitation on the UI:
- `invite["label"]` - Name of the inviter
- `invite["profileUrl"]` - URL with inviter logo (optional - maybe missed in the invitation)
- `invite["goal"]` - A text defining the goal of the connection establishing (optional - maybe missed in the invitation)

More information about Aries Out-Of-Band invitation and related protocol you can find [here](https://github.com/hyperledger/aries-rfcs/tree/master/features/0434-outofband).

### URL invitation format

Both invitation types can also be represented in form of URL:

* Aries Connection invitation - https://<domain>/<path>?c_i=[Base-64 encoded invitation]
* Aries Out-Of-Band invitation - https://<domain>/<path>?oob=[Base-64 encoded invitation]

In this case, you need to decode Base-64 string first. The result value should match the formats we described above.

#### URL invitation format example:

```
http://vas.evernym.com:80/agency/msg?c_i=eyJsYWJlbCI6IkFjbWUiLCJzZXJ2aWNlRW5kcG9pbnQiOiJodHRwOi8vdmFzLmV2ZXJueW0uY29tOjgwL2FnZW5jeS9tc2ciLCJyZWNpcGllbnRLZXlzIjpbIjNhVkhWZEFxZnBKSmVROG1mdm5UV0Y0MVpoYUxidVVLQXJ3UlVCRldlWjNRIl0sInJvdXRpbmdLZXlzIjpbIjNhVkhWZEFxZnBKSmVROG1mdm5UV0Y0MVpoYUxidVVLQXJ3UlVCRldlWjNRIiwiM21vM1A2WHpEekJ2dWt0Q2dEUWFyQUN6emVWN3p4clNFeG5pY3B1SDd0ODMiXSwicHJvZmlsZVVybCI6Imh0dHBzOi8vczMudXMtZWFzdC0yLmFtYXpvbmF3cy5jb20vcHVibGljLWRlbW8tYXJ0aWZhY3RzL2RlbW8taWNvbnMvY2JBQ01FLnBuZyIsIkB0eXBlIjoiZGlkOnNvdjpCekNic05ZaE1yakhpcVpEVFVBU0hnO3NwZWMvY29ubmVjdGlvbnMvMS4wL2ludml0YXRpb24iLCJAaWQiOiI4YWE1ZTZjOS1mZjZkLTQ0NDUtOWU1Ni1iNDU1MjQxZTVlZGIifQ==

http://vas.evernym.com:80/agency/msg?oob=eyJAdHlwZSI6Imh0dHBzOi8vZGlkY29tbS5vcmcvb3V0LW9mLWJhbmQvMS4wL2ludml0YXRpb24iLCJAaWQiOiI2OTIxMmEzYS1kMDY4LTRmOWQtYTJkZC00NzQxYmNhODlhZjMiLCJsYWJlbCI6IkZhYmVyIENvbGxlZ2UiLCAiZ29hbF9jb2RlIjoiaXNzdWUtdmMiLCJnb2FsIjoiVG8gaXNzdWUgYSBGYWJlciBDb2xsZWdlIEdyYWR1YXRlIGNyZWRlbnRpYWwiLCJoYW5kc2hha2VfcHJvdG9jb2xzIjpbImh0dHBzOi8vZGlkY29tbS5vcmcvZGlkZXhjaGFuZ2UvMS4wIiwiaHR0cHM6Ly9kaWRjb21tLm9yZy9jb25uZWN0aW9ucy8xLjAiXSwic2VydmljZSI6WyJkaWQ6c292OkxqZ3BTVDJyanNveFllZ1FEUm03RUwiXX0
```

### 2. Create Connection state object using received Invitation.

Successful execution will return a connection handle.
This handle points to created Connection state object and should be used for later operations (sending messages through the connection) related to this connection.

#### iOS

* For `aries connection` invitation:

   ```objc
   [appDelegate.sdkApi connectionCreateWithInvite: invitationId
           inviteDetails: inviteDetails
           completion:^(NSError *error, NSInteger connectionHandle) {
               // ...
           }];
   ```

* For `aries out-of-band` invitation:

   ```objc
   [appDelegate.sdkApi connectionCreateWithOutofbandInvite: invitationId
           invite: inviteDetails
           completion:^(NSError *error, NSInteger connectionHandle) {
               // ...
           }];
   ```

#### Android

* For `aries connection` invitation:

   ```java
   int connectionHandle = ConnectionApi.vcxCreateConnectionWithInvite(invitationId, invitationDetails).get();
   ```

* For `aries out-of-band` invitation:

   ```java
   int connectionHandle = ConnectionApi.vcxCreateConnectionWithOutofbandInvite(invitationId, invitationDetails).get();
   ```

### 3. Check whether connection has been already established.

The previous step only creates a Connection state object but not actually accept the invitation.
Before accepting a connection invitation you need to check that it has not been used yet.
In order to check does connection already exists, we need to retrieve invitations that were used during the creation of existing connections and compare them with the received invitation.

1. Extract original invitation for existing connections

   1. Deserialize connection

      #### iOS
       ```objC
       [appDelegate.sdkApi connectionDeserialize:serializedConnection
               completion:^(NSError *error, NSInteger connectionHandle) {
                   // ...
               }];
       ```

      #### Android
       ```java
       int connectionHandle = ConnectionApi.connectionDeserialize(serializedConnection).get();
       ```
   1. Get invitation 

      #### iOS
       ```objC
       [appDelegate.sdkApi getConnectionInviteDetails:connectionHandle
                                          abbreviated:FALSE
                                           completion:^(NSError *error, NSInteger connectionInvite) {
                                              // ...
                                          }];
       ```

      #### Android
       ```java
       String connectionInvite = ConnectionApi.connectionInviteDetails(handle, abbreviated).get();
       ```

1. Compare invitations -invitations match when one of the following fields is the same for both of them:

   * `@id` field (means exactly the same invitation)
   * `public_did` field (invitation from same Inviter)
   * `recipient_keys[0]` field (invitation from same Inviter)
    
1. If you find that connection already exists for the received invitation you would better reuse the existing connection rather than establish a new one.
You can read how to reuse existing connection in the [section](#reusing-existing-connections).
   
### 4.Accept connection invitation.

If there is no existing connection, and you want to accept the invitation to establish a connection you need to create Pairwise Cloud Agent and send `Connection Request` message.

* This Agent will be used for one particular connection, so a new Pairwise Cloud Agent will be created for every connection you establish.

* `Connection Request` message contains:
    * Public key of the Invitee which Inviter will be used to encrypt all following messages.
    * Cloud Agent public endpoint.
    * Pairwise Cloud Agent public keys which will be used to encrypt sending messages.

* All communication between Inviter <-> Invitee and Invite/Inviter <-> Pairwise Cloud Agent happens in encrypted way.

* The Invitee private keys to decrypt messages from Inviter or Cloud Agent are stored into Mobile SDK Wallet in encrypted form and cannot be read.

* Pairwise Cloud Agent receives messages in encrypted form, so only the Invitee can read the message content. 

#### iOS
```objc
[appDelegate.sdkApi connectionConnect: connectionHandle
                       connectionType: connType
        completion:^(NSError *error, NSInteger inviteDetails) {
            // ...
        }];
```

#### Android
```java
ConnectionApi.vcxConnectionConnect(connectionHandle, connType).get();
```

### 5. Await Connection is completed.

The connection will be completed when `Connection Response` message is received back from the Inviter. This message contains public keys which will be used by the Inviter for messages exchange. Inviter may change original Invitation keys as it was transferred using some public way.

Call following code in loop until returned state is not equal `4` (`Accepted`). 
   
   ### iOS

    ```objc
    while(1) {
        [appDelegate.sdkApi connectionUpdateState:connectionHandle
            completion:^(NSError *error, NSInteger state) {
                    if (state == 4){
                        break;
                    }
        }
    }
    ```

   ### Android

    ```java
    int state = -1;
    while(state != 4){
        state = ConnectionApi.vcxConnectionUpdateState(connectionHandle).get();
    }
    ```

### 6. Serialize Connection object and store in the application storage.

Once we get the connection completed we need to store it for future usages.

1. Serialize Connection object
   #### iOS
    ```objC
    [appDelegate.sdkApi connectionSerialize:connectionHandle
            completion:^(NSError *error, NSString *serializedConnection)) {
                // ...
            }];
    ```

   #### Android
    ```java
        String serializedConnection = ConnectionApi.connectionSerialize(connectionHandle).get();
    ``` 

2. Fetch Connection `pwDid`. This field will be unique among all established connections.
    This field will be also needed during the handling of messages received from the Cloud Agent (in order to associate messages with serialized connections).

    #### iOS
        ```objC
        [appDelegate.sdkApi connectionGetPwDid:connectionHandle
                completion:^(NSError *error, NSString *serializedConnection)) {
                    // ...
                }];
        ```
    
    #### Android
        ```java
            String pwDid = ConnectionApi.connectionGetPwDid(connectionHandle).get();
        ``` 

3. It is up to the developer regarding what data to store in the application. On of the possible formats may match the following structure:
    ```
    {
        "pwDid" - string, // connection pairwise DID
        "serialized" - string, // serialized SDK object
   
        // metadata to show on the UI
        "name" - string, // inviter name
        "logo" - string, // inviter logo
        "timestamp" - int // optional, time of establishing the credential (it can be shown on the UI and used for sorting) 
   
        "status" - string, // connection status (pending / completed)
   
        // optionally
        "invitation" - string // original invitation was used to establish the connection, 
                                It will simply check for already accepted invitations 
                                The step `1. Extract original invitation for existing connections` will not be needed anymore.
    }
    ```

4. Every time in the future you want to perform some operations using the created connection you firstly need to fetch Connection object from the storage and next deserialize SDK object from its serialized representation (receive a new handle).

## Reusing Existing Connections

With adding more and more connections, its getting hard for user to remember which connections already established. There is potential that some of the new connections user tries to establish already exists in list of connections (e.g. QR code was scanned multiple types). In this case we should not create new connection and try to reuse existing one.

#### Aries Connection invitation

A regular Aries connection protocol does not contain connection redirection steps.

#### Aries Out-Of-Band Connection invitation

Aries RFCs provides [Out-of-Band](https://github.com/hyperledger/aries-rfcs/tree/master/features/0434-outofband) protocol describing the way of creating new connections and reusing of existing.

The steps need to be taken by the app depends on the format of received Out-of-Band invitation.

Bellow we will describe steps for a case when there is no action attached (`request~attach`) to the invitation.

If you want to get guidelines on how to handle all possible Out-of-Band invitation cases go to the [document](./Out-of-Band.md)

For this section we assume the following facts:
1. Connection matching to the provided invitation is already exists.
1. Out-of-Band invitation contains `handshake_protocols`
1. Out-of-Band invitation does not `request~attach` or it's an empty array.

1. Deserialize existing Connection state object

   #### iOS
    ```objC
    [appDelegate.sdkApi connectionDeserialize:serializedConnection
            completion:^(NSError *error, NSInteger connectionHandle) {
                // ...
            }];
    ```

   #### Android
    ```java
    int existingConnectionHandle = ConnectionApi.connectionDeserialize(serializedConnection).get();
    ```

1. Send Connection Reuse message

   #### iOS
    ```objC
    [appDelegate.sdkApi connectionSendReuse:existingConnectionHandle
            invite:newInvite
            withCompletion:^(NSError *error) {
                // ...
            }];
    ```

   #### Android
    ```java
     ConnectionApi.connectionSendReuse(existingConnectionHandle, newInvite).get();
    ```

1. Await for `handshake-reuse-accepted` message received for old Connection.

   See [messages documentation](MessagesFlow.md) for message download information.
   Pending messages with `handshake-reuse-accepted` type should be downloaded.

   Next, update message status as read. See [messages documentation](MessagesFlow.md) for message update information.

## Deleting Connections

It may happen that after some time a User wants to delete connections that are no longer need to him.
In order to delete a connection you need to perform the next steps:

1. Delete a Pairwise Cloud Agent associated with the Connection, so that it cannot be used anymore for sending or receiving messages.
   
   1.1. Deserialize existing Connection state object
    
       #### iOS
        ```objC
        [appDelegate.sdkApi connectionDeserialize:serializedConnection
                completion:^(NSError *error, NSInteger connectionHandle) {
                    // ...
                }];
        ```
    
       #### Android
        ```java
        int connectionHandle = ConnectionApi.connectionDeserialize(serializedConnection).get();
        ```

    1.2. Delete Pairwise Cloud Agent associated with the Connection
    
       #### iOS
        ```objC
        [appDelegate.sdkApi deleteConnection:connectionHandle
                withCompletion:^(NSError *error) {
                    // ...
                }];
        ```
    
       #### Android
        ```java
         ConnectionApi.deleteConnection(connectionHandle).get();
        ```

1. Delete connection data from the application storage.

## Expected errors with establishing connection

### Connection already exists

It is expected use cases when user on mobile device tries to establish connection which already exists (user already connected before tries again). 
In that case, we don't need to reset connection (delete existing connection and create new connection with same pair). You can reuse existing connection.

You can find more details about this use case [here](#reusing-existing-connections).

## Next Step

Now your application is able to established connections with other parties.
You are ready to ready how to [receive verifiable credentials](4.Credentials.md).
