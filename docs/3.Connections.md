# 3. Connections

To set up a connection between the Inviter (server) and the Invitee (client) the process must complete these steps:

  1. Check type of invitation: [aries connection](#aries-invitation) and [aries out-of-band](#out-of-band-invitation) formats are supported.
  2. Ensure that connection has not been established yet.
  3. Depending on the invitation type call according methods.
  4. Await Connection is completed.

To accept a connection invitation and form a new connection, mobile SDK generates a new unique DID and associated keypair. The public key is then included in the response to the Inviter. 

This exchange results in both parties recording the other's public key, thereby forming a unique pairwise encryption channel. Mobile SDK can form an unlimited number of connections in this way.

> **NOTE:** library should be initialized before using connections API. See [initialization documentation](2.Initialization.md)

## Establish connection

### 1. Identify type of received invitation

### Aries Connection invitation

The value of `@type` field **must** end with `connections/1.0/invitation`.

#### Example:

```json
{
    "label": "Acme",
    "serviceEndpoint": "http://vas.evernym.com:80/agency/msg",
    "recipientKeys": [
        "9NR9NYh5z5HHu6nLHnQWXczUqRwrdoL4KBUWvo2fE6vj"
    ],
    "routingKeys": [
        "9NR9NYh5z5HHu6nLHnQWXczUqRwrdoL4KBUWvo2fE6vj",
        "3mo3P6XzDzBvuktCgDQarACzzeV7zxrSExnicpuH7t83"
    ],
    "profileUrl": "https://s3.us-east-2.amazonaws.com/public-demo-artifacts/demo-icons/cbACME.png",
    "@type": "did:sov:BzCbsNYhMrjHiqZDTUASHg;spec/connections/1.0/invitation",
    "@id": "467f6449-7d1f-4a9f-ada7-09d6444af083"
}
```

Invitation may optionally contain meta information describing the Inviter:
- `invite["label"]` - Name of the inviter
- `invite["profileUrl"]` - URL with inviter logo (optional)

More information about Aries Connection invitation and related protocol you can find [here](https://github.com/hyperledger/aries-rfcs/tree/master/features/0160-connection-protocol). 

### Aries Out-of-band invitation

The value of `@type` field **must** end with `/out-of-band/1.0/invitation`.

#### Example:

```json
{
  "@type": "https://didcomm.org/out-of-band/1.0/invitation",
  "@id": "9NR9NYh5z5HHu6nLHnQWXczUqRwrdoL4KBUWvo2fE6vj",
  "label": "Faber College",
  "goal_code": "issue-vc",
  "goal": "To issue a Faber College Graduate credential",
  "handshake_protocols": [
      "https://didcomm.org/didexchange/1.0",
      "https://didcomm.org/connections/1.0"
      ],
  "request~attach": [
    {
        "@id": "request-0",
        "mime-type": "application/json",
        "data": {
            "json": "<json of protocol message>"
        }
    }
  ],
  "service": ["did:sov:LjgpST2rjsoxYegQDRm7EL"]
}
```

Invitation may optionally contain meta information describing the Inviter:
- `invite["label"]` - Name of the inviter
- `invite["profileUrl"]` - URL with inviter logo (optional)

More information about Aries Out-Of-Band invitation and related protocol you can find [here](https://github.com/hyperledger/aries-rfcs/tree/master/features/0434-outofband).

### URL invitation format

Both invitation types can be also represented in form of URL:

* Aries Connection invitation - https://<domain>/<path>?c_i=<invitationString>
* Aries Out-Of-Band invitation - https://<domain>/<path>?oob=<invitationString>

`c_i/oob` is a required parameter containing Base-64 encoded representation of invitation.
After decoding of base64 string, the result should match to the formats we described above.

#### URL sample

```
http://vas.evernym.com:80/agency/msg?c_i=eyJsYWJlbCI6IkFjbWUiLCJzZXJ2aWNlRW5kcG9pbnQiOiJodHRwOi8vdmFzLmV2ZXJueW0uY29tOjgwL2FnZW5jeS9tc2ciLCJyZWNpcGllbnRLZXlzIjpbIjNhVkhWZEFxZnBKSmVROG1mdm5UV0Y0MVpoYUxidVVLQXJ3UlVCRldlWjNRIl0sInJvdXRpbmdLZXlzIjpbIjNhVkhWZEFxZnBKSmVROG1mdm5UV0Y0MVpoYUxidVVLQXJ3UlVCRldlWjNRIiwiM21vM1A2WHpEekJ2dWt0Q2dEUWFyQUN6emVWN3p4clNFeG5pY3B1SDd0ODMiXSwicHJvZmlsZVVybCI6Imh0dHBzOi8vczMudXMtZWFzdC0yLmFtYXpvbmF3cy5jb20vcHVibGljLWRlbW8tYXJ0aWZhY3RzL2RlbW8taWNvbnMvY2JBQ01FLnBuZyIsIkB0eXBlIjoiZGlkOnNvdjpCekNic05ZaE1yakhpcVpEVFVBU0hnO3NwZWMvY29ubmVjdGlvbnMvMS4wL2ludml0YXRpb24iLCJAaWQiOiI4YWE1ZTZjOS1mZjZkLTQ0NDUtOWU1Ni1iNDU1MjQxZTVlZGIifQ==
```

### 2. Create Connection state object using received Invitation.

Successful execution will return connection handle (associating the connection) 
This handle points to created Connection state object and should be used for latter operations related to this connection.

#### iOS

* For `aries connection` invitation:

   ```objc
   [appDelegate.sdkApi connectionCreateWithInvite: invitationId
           inviteDetails: inviteDetails
           completion:^(NSError *error, NSInteger connectionHandle) {
               // ...
           }];
   ```

* For `aries out-of-band` invitation:

   ```objc
   [appDelegate.sdkApi connectionCreateWithOutofbandInvite: invitationId
           invite: inviteDetails
           completion:^(NSError *error, NSInteger connectionHandle) {
               // ...
           }];
   ```

#### Android

* For `aries` invitation:

   ```java
   int connectionHandle = ConnectionApi.vcxCreateConnectionWithInvite(invitationId, invitationDetails).get();
   ```

* For `out-of-band` invitation:

   ```java
   int connectionHandle = ConnectionApi.vcxCreateConnectionWithOutofbandInvite(invitationId, invitationDetails).get();
   ```

### 3. Check whether connection has been already established.

The previous step only creates a Connection state object but not actually accept the invitation.
Before accepting a connection invitation you need to check that it has not been already used.


To check does connection already exists, we need to retrieve invitations that were used during the creation of existing connections and compare them with the new ones.

1. Extract original invitation for existing connections

   1. Deserialize connection

      #### iOS
       ```objC
       [appDelegate.sdkApi connectionDeserialize:serializedConnection
               completion:^(NSError *error, NSInteger connectionHandle) {
                   // ...
               }];
       ```

      #### Android
       ```java
       int connectionHandle = ConnectionApi.connectionDeserialize(serializedConnection).get();
       ```
   1. Get invite details

      #### iOS
       ```objC
       [appDelegate.sdkApi getConnectionInviteDetails:connectionHandle
                                          abbreviated:FALSE
                                           completion:^(NSError *error, NSInteger connectionInvite) {
                                              // ...
                                          }];
       ```

      #### Android
       ```java
       String connectionInvite = ConnectionApi.connectionInviteDetails(handle, abbreviated).get();
       ```
    
1. Compare `aries` invitations

   For `aries` invitations should match one of fields:
   * `@id` field (means exactly the same invitation)
   * `public_did` field (invitation from same Inviter)
   * `recipient_keys[0]` field (invitation from same Inviter)
    
1. Act base on type of matched invitation \
If you find that the corresponding connection already exists you likely better reuse the existing one. 
In the [Connection Redirection document](./7.ConnectionRedirection.md) you can ready how to reuse existing connection instead of creating a new one.

### 4.Accept connection invitation.

If you want to accept the invitation and established a connection you need to create Pairwise Cloud Agent and send Connection Request message.

   #### iOS
    ```objc
    [appDelegate.sdkApi connectionConnect: connectionHandle
                           connectionType: connType
            completion:^(NSError *error, NSInteger inviteDetails) {
                // ...
            }];
    ```

   #### Android
    ```java
    ConnectionApi.vcxConnectionConnect(connectionHandle, connType).get();
    ```

### 5. Await Connection is completed.

   Call following code in loop until returned state is not equal `4` (`Accepted`). 
   
   ### iOS

    ```objc
    while(1) {
        [appDelegate.sdkApi connectionUpdateState:connectionHandle
            completion:^(NSError *error, NSInteger state) {
                    if (state == 4){
                        break;
                    }
        }
    }
    ```

   ### Android

    ```java
    int state = -1;
    while(state != 4){
        state = ConnectionApi.vcxConnectionUpdateState(connectionHandle).get();
    }
    ```

### 6. Serialize Connection object and store in the application storage.

Once we get the connection completed we need to store it for future usages.

1. Serialize Connection object
   #### iOS
    ```objC
    [appDelegate.sdkApi connectionSerialize:connectionHandle
            completion:^(NSError *error, NSString *serializedConnection)) {
                // ...
            }];
    ```

   #### Android
    ```java
        String serializedConnection = ConnectionApi.connectionSerialize(connectionHandle).get();
    ``` 

2. Fetch Connection `pwDid` \
    This field will be unique among all established connections.
    This field will be also needed during the handling of messages received from the Cloud Agent (in order to associate messages with serialized connections).

    #### iOS
        ```objC
        [appDelegate.sdkApi connectionGetPwDid:connectionHandle
                completion:^(NSError *error, NSString *serializedConnection)) {
                    // ...
                }];
        ```
    
    #### Android
        ```java
            String pwDid = ConnectionApi.connectionGetPwDid(connectionHandle).get();
        ``` 

3. It is up to the developer regarding what data to store in the application. On of the possible formats may match the following structure:
    ```
    {
        "pwDid" - string, // connection pairwise DID
        "serialized" - string, // serialized SDK object
        "name" - string, // inviter name
        "logo" - string, // inviter logo
   
        // optionally
        "ivitation" - string // original invitation was used to establish the connection, 
                                It will simply check for already accepted invitations 
                                `1. Extract original invitation for existing connections` step will not be needed anymore
    }
    ```

4. Every time in the future you want to perform some operations using the created connection you need firstly to fetch Connection object from the storage and next deserialize SDK object from its serialized representation (receive a new handle).

## Expected errors with establishing connection

### Connection already exists

It is expected use cases when user on mobile device tries to establish connection which already exists (user already connected before tries again). 
In that case, we don't need to reset connection (delete existing connection and create new connection with same pair). You can reuse existing connection.

You can find more details about this use case here: [7. Connection redirection](7.ConnectionRedirection.md)
