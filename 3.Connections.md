# 3. Connections

- [3. Connections](#3-connections)
  - [Establishing connection via QR Code](#establishing-connection-via-qr-code)
    - [iOS](#ios)
    - [Android](#android)


 Currently, Connect.Me can only respond to a connection invitation which has been generated by the inviter. It can respond to connection invites in two ways: Scanning a properly formatted QR code or deeplinking. 

To accept a connection invitation and form a new connection, Connect.Me generates a new unique DID & associated key pair. The public key is then included in the response to the inviter. 

This results in both parties having recorded the othersâ€™ public keys, essentially forming a unique pairwise encryption channel. Connect.Me can form an unlimited number of connections this way.


## Establishing connection via QR Code

### iOS
> from addNewConn in mobile-starter-master/ios/CMeSdkObjc/CMeSdkObjc/ViewController.m

```objC
- (IBAction)addNewConn:(id)sender {
    AppDelegate *appDelegate = (AppDelegate*)[[UIApplication sharedApplication] delegate];

    NSUserDefaults *standardUserDefaults = [NSUserDefaults standardUserDefaults];

    NSString *connConfig = self.addConnConfig.text;

    NSError* error;
    NSMutableDictionary *configValues = [NSJSONSerialization JSONObjectWithData: [connConfig dataUsingEncoding: NSUTF8StringEncoding] options: NSJSONReadingMutableContainers error: &error];

    [appDelegate.sdkApi connectionCreateWithInvite: [configValues valueForKey: @"id"]
        inviteDetails: connConfig
        completion:^(NSError *error, NSInteger connectionHandle) {
            if (error != nil && error.code != 0)
            {
                // handle errors
                return;
            }

            // connectionConnect with connectionHandle
            [appDelegate.sdkApi connectionConnect: connectionHandle
                connectionType: @"{\"connection_type\":\"QR\",\"phone\":\"\"}"
                completion: ^(NSError *error, NSString *inviteDetails) {
                    if (error != nil && error.code != 0)
                    {
                        // handle errors
                        return;
                    }
                    [appDelegate.sdkApi connectionSerialize: connectionHandle
                        completion:^(NSError *error, NSString *state) {
                        if (error != nil && error.code != 0)
                        {
                            // handle errors
                            return;
                        }
                        // Store the serialized connection
                        if (standardUserDefaults) {
                            [standardUserDefaults setObject: state forKey: @"serializedConnection"];
                            [standardUserDefaults synchronize];
                        }
                    }];
            }];
    }];
}
```


### Android

> from addConnectionOnClick in mobile-starter-master/android/CMeSdkJava/app/src/main/java/me/connect/sdk/java/ConnectMeVcx.java

```java
    public void addConnectionOnClick(View v) {
        EditText editText   = (EditText)findViewById(R.id.editText2);
        String invitationDetails = editText.getText().toString();
        Log.d(TAG, "connection invitation is set to: " + invitationDetails);

        try {
            JSONObject json = new JSONObject(invitationDetails);
            sdkApi.createConnectionWithInvite(json.getString("id"), invitationDetails, new CompletableFuturePromise<>(connectionHandle -> {
                if(connectionHandle != -1) {
                    sdkApi.vcxAcceptInvitation(connectionHandle, "{\"connection_type\":\"QR\",\"phone\":\"\"}", new CompletableFuturePromise<>(inviteDetails -> {
                        if(invitationDetails != null) {
                            sdkApi.getSerializedConnection(connectionHandle, new CompletableFuturePromise<>(state -> {
                                // handle serialized connection state
                            }, (t) -> {
                                // handle errors
                                return null;
                            }));
                        }
                    }, (t) -> {
                        // handle successful result
                        return null;
                    }));
                }
            }, (t) -> {
                // handle errors
                return -1;
            }));
        } catch (JSONException e) {
            // handle errors
        }
    }
```

