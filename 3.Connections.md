# 3. Connections

- [3. Connections](#3-connections)
  - [1. Establishing connection via QR Code](#1-establishing-connection-via-qr-code)
    - [iOS](#ios)
    - [Android](#android)
  - [2. Establishing connection via DeepLink](#2-establishing-connection-via-deeplink)
  - [3. Example of connection invitation oject](#3-example-of-connection-invitation-oject)
  

 Currently, Connect.Me can respond only to a connection invitation that has been generated by the Inviter, and it can respond in two ways: 
 
 * Scanning a properly formatted QR code
 
 * Deeplinking 

To accept a connection invitation and form a new connection, Connect.Me generates a new unique DID and associated keypair. The public key is then included in the response to the Inviter. 

This exchange results in both parties recording the othersâ€™ public keys, essentially forming a unique pairwise encryption channel. Connect.Me can form an unlimited number of connections in this way.


## 1. Establishing connection via QR Code


### iOS
> from addNewConn in mobile-starter-master/ios/CMeSdkObjc/CMeSdkObjc/ViewController.m


<!--For what purpose is this code provided?-->

```objC
- (IBAction)addNewConn:(id)sender {
    AppDelegate *appDelegate = (AppDelegate*)[[UIApplication sharedApplication] delegate];

    NSUserDefaults *standardUserDefaults = [NSUserDefaults standardUserDefaults];

    NSString *connConfig = self.addConnConfig.text;

    NSError* error;
    NSMutableDictionary *configValues = [NSJSONSerialization JSONObjectWithData: [connConfig dataUsingEncoding: NSUTF8StringEncoding] options: NSJSONReadingMutableContainers error: &error];

    [appDelegate.sdkApi connectionCreateWithInvite: [configValues valueForKey: @"id"]
        inviteDetails: connConfig
        completion:^(NSError *error, NSInteger connectionHandle) {
            if (error != nil && error.code != 0)
            {
                // handle errors
                return;
            }

            // connectionConnect with connectionHandle
            [appDelegate.sdkApi connectionConnect: connectionHandle
                connectionType: @"{\"connection_type\":\"QR\",\"phone\":\"\"}"
                completion: ^(NSError *error, NSString *inviteDetails) {
                    if (error != nil && error.code != 0)
                    {
                        // handle errors
                        return;
                    }
                    [appDelegate.sdkApi connectionSerialize: connectionHandle
                        completion:^(NSError *error, NSString *state) {
                        if (error != nil && error.code != 0)
                        {
                            // handle errors
                            return;
                        }
                        // Store the serialized connection
                        if (standardUserDefaults) {
                            [standardUserDefaults setObject: state forKey: @"serializedConnection"];
                            [standardUserDefaults synchronize];
                        }
                    }];
            }];
    }];
}
```


### Android

> from addConnectionOnClick in mobile-starter-master/android/CMeSdkJava/app/src/main/java/me/connect/sdk/java/ConnectMeVcx.java

<!--For what purpose is this code provided?-->

```java
    public void addConnectionOnClick(View v) {
        EditText editText   = (EditText)findViewById(R.id.editText2);
        String invitationDetails = editText.getText().toString();
        Log.d(TAG, "connection invitation is set to: " + invitationDetails);

        try {
            JSONObject json = new JSONObject(invitationDetails);
            sdkApi.createConnectionWithInvite(json.getString("id"), invitationDetails, new CompletableFuturePromise<>(connectionHandle -> {
                if(connectionHandle != -1) {
                    sdkApi.vcxAcceptInvitation(connectionHandle, "{\"connection_type\":\"QR\",\"phone\":\"\"}", new CompletableFuturePromise<>(inviteDetails -> {
                        if(invitationDetails != null) {
                            sdkApi.getSerializedConnection(connectionHandle, new CompletableFuturePromise<>(state -> {
                                // handle serialized connection state
                            }, (t) -> {
                                // handle errors
                                return null;
                            }));
                        }
                    }, (t) -> {
                        // handle successful result
                        return null;
                    }));
                }
            }, (t) -> {
                // handle errors
                return -1;
            }));
        } catch (JSONException e) {
            // handle errors
        }
    }
```

## 2. Establishing a connection via DeepLink

The process of accepting connection inviations via deep link is similar to scaning a QR code: the only difference is the way how we retrieve full JSON object of connection invitation. With QR code, whole object is included in the QR data, while with deep links the flow can contain the additional step of downloading the whole object from a third-party resource (based on short link, received in SMS as example). <!--This parenthetical needs clarification-->

## 3. Example of a connection invitation object

```json 
{
    "id": "NjAzNTY",
    "s": {
        "d": "JFatV7UCKPsSTqDBcuUBiN",
        "dp": {
            "d": "3x2MKKabjGxvMQwLBk5yWn",
            "k": "2cDPDb4bdSW1UFtKUV2y2b1TfG4T36T3miBrLRsFnwLx",
            "s": "YFZQahGN2o08VtMKVTOJIpyJnoQFC2snMre/xabgGNOlUuMNAjtFCwvlVGbPdQ92Kh4iYiHadkjdv81y5OeJCA=="
        },
        "l": "https://s22.postimg.cc/wu8r1enjl/evernym.png",
        "n": "Evernym Staging",
        "v": "AQMSbbDhsRJbgpLh84pFTBJBArh6qQ2vBiBfJPzeEMZA"
    },
    "sa": {
        "d": "j9PTs554BYkgMggRhiJip",
        "e": "eas.pstg.evernym.com:80/agency/msg",
        "v": "PyGuGpa49Fii2CLiRG6Wff7NddPg3aAuyi4BXzerWwj"
    },
    "sc": "MS-101",
    "sm": "message created",
    "t": "there",
    "threadId": null,
    "version": "1.0"
}

```

