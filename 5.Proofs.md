# 6. Proof Request Flow

To successfully fill and sign a proof request, the following process must be completed: 

  - [1. Download messages and filter objects of type `proofReq`](#1-download-messages-and-filter-objects-of-type-proofreq)
  - [2. Deserialize the connection and get the connection handle](#2-deserialize-the-connection-and-get-the-connection-handle)
  - [3. Create proof with a message ID](#3-create-proof-with-a-message-id)
  - [4. Retrieve proof matching credentials](#4-retrieve-proof-matching-credentials)
  - [5. Fill in missing self-attested attributes](#5-fill-in-missing-self-attested-attributes)
  - [6. Generate proof](#6-generate-proof)
  - [7. Sending proof](#7-sending-proof)
  - [Complete Flow in JavaScript: Step by Step](#complete-flow-in-javascript-step-by-step)

--- 

## Proof Request Flow
![Proof Request Flow](wiki-images/ProofRequestFlowConnectMe.png)<!--This illustration has a decision point but it doesn't use the diamond. Bonnie will create a new illustration.-->

--- 
## 1. Download messages and filter objects of type `proofReq`

Call `downloadMessages('MS-103', null, pwDID)` and then filter the objects of type `proofReq`. From there use `decryptedPayload` and the `uid` from the object. <!-- [Q1] Is the system acting or are you telling the developer to do something? If it's the system, which component in the process is performing the actions: the mobile app or the server?-->

Example of the proof-request message object in JSON: 

```json
{
    "decryptedPayload": "{\"@type\":{\"name\":\"PROOF_REQUEST\",\"ver\":\"1.0\",\"fmt\":\"json\"},\"@msg\":\"{\\\"@type\\\":{\\\"name\\\":\\\"PROOF_REQUEST\\\",\\\"version\\\":\\\"1.0\\\"},\\\"@topic\\\":{\\\"mid\\\":0,\\\"tid\\\":0},\\\"proof_request_data\\\":{\\\"nonce\\\":\\\"220867029780621153091790\\\",\\\"name\\\":\\\"Basic Info\\\",\\\"version\\\":\\\"0.1\\\",\\\"requested_attributes\\\":{\\\"Number\\\":{\\\"name\\\":\\\"Number\\\"},\\\"First Name\\\":{\\\"name\\\":\\\"First Name\\\"},\\\"Last Name\\\":{\\\"name\\\":\\\"Last Name\\\"},\\\"Color\\\":{\\\"name\\\":\\\"Color\\\"},\\\"Job Title\\\":{\\\"name\\\":\\\"Job Title\\\"}},\\\"requested_predicates\\\":{},\\\"non_revoked\\\":null},\\\"msg_ref_id\\\":null,\\\"from_timestamp\\\":null,\\\"to_timestamp\\\":null,\\\"thread_id\\\":null}\"}",
    "deliveryDetails":[],
    "payload":null,
    "refMsgId": null,
    "senderDID" : "JFatV7UCKPsSTqDBDAUBiN",
    "statusCode": "MS-103",
    "type":"proofReq",
    "uid":"OWY3MDd"
}
```

### iOS

<!--[Q2] Where is this code visible?-->

```ObjC
[[sdkAPI] downloadMessages:@"MS-103" uid_s:nil pwdids:pw_did completion:^(NSError *error, NSString *messages) {
    NSMutableArray *myMessages = [NSJSONSerialization JSONObjectWithData:[messages dataUsingEncoding:NSUTF8StringEncoding] options:NSJSONReadingMutableContainers error:&error];
    // filter myMesssages to type = proofReq
    for(NSDictionary *item in myMessages) {
        for(NSDictionary *msg in item[@"msgs"]) {
            if ([msg[@"type"] isEqualToString: @"proofReq"]) {
                 /// continue with next step
            }
        }
    }
}
```

### Android

<!--[Q3] Where is this code visible?-->

```java
LibVCXApi.vcxGetMessages(messageStatus, uid_s, pwdids)
    .exceptionally((t) -> {
        // handle error result
        return null;
        })
    .thenAccept(result -> {
        // handle successful result
    });
```


### Javascript 

<!--[Q4] Where is this code visible?-->

```javascript
const MESSAGE_PENDING = 'MS-103';
// Get messages will have type 'profReq'
const downloadMessages = await RNIndy.downloadMessages(
    MESSAGE_PENDING,
    null,
    this.props.connection.pwDid,
);

const msgObject = JSON.parse(downloadMessages)[0]
```

---

## 2. Deserialize the connection and get the connection handle

Once we <!--[Q5] What/Who gets the object? The mobile app? --> get the proof object from the Agency, we need to use proof `requestedAttributes` and fill it with our automated data from certificate(s) or fill it in manually ("self-attested attributes"). <!--[Q6] Who/What uses the proof and who/what does the filling?-->


### iOS

<!--[Q7] Where is this code visible?-->

```ObjC
[[sdkAPI] connectionDeserialize: serializedConnection completion:^(NSError *error, NSInteger connectionHandle) {
// handle errors first
}
```

### Android

<!--[Q8] Where is this code visible?-->

```java
ConnectionApi.connectionDeserialize(serializedConnection)
    .exceptionally((t) -> {
        // handle error response
        return -1;
    }).thenAccept(result -> {
        if (result != -1) {
            // handle successful response
        }
    });
```

For the testing flow, use an example where the user provides these details:
	
* First Name
* Last Name
* Color <!--[Q9] Color of what? If you mean skin color this will need to be changed to another attribute.-->
* Job Title
* Number

Original requested-attributes data will look like this in JSON: 

```json
    ...(rest proof request data)...
	  "requested_attributes": {
	        "First Name": {
	            "name": "First Name"
	        },
	        "Color": {
	            "name": "Color"
	        },
	        "Number": {
	            "name": "Number"
	        },
	        "Last Name": {
	            "name": "Last Name"
	        },
	        "Job Title": {
	            "name": "Job Title"
	        }
	   }
	   ...
```

After we <!--[Q10] What/Who does the serializing?-->serialize the proof request, request attributes should look like the example below for self-attested attributes: 

```json
    ...(rest proof request data)...
    "requested_attributes": [
        {
            "First Name": "fieldValue"
        },
        {
            "Color": "fieldValue"
        },
        {
            "Number": "fieldValue"
        },
        {
            "Last Name": "fieldValue"
        },
        {
            "Job Title": "fieldValue"
        }
    ]
    ...
```
    
### iOS

```objC
 [[sdkAPI] connectionDeserialize: serializedConnection completion:^(NSError *error, NSInteger connectionHandle) {
    
    NSMutableDictionary *decryptedPayloadMsg = [NSJSONSerialization JSONObjectWithData:[decryptedPayload[@"@msg"] dataUsingEncoding:NSUTF8StringEncoding] options:NSJSONReadingMutableContainers error:&error];
            
    NSDictionary *stringifiableProofRequestData = @{
        @"agent_did": @"",
        @"agent_vk": @"",
        @"link_secret_alias": @"main",
        @"my_did": @"",
        @"my_vk": @"",
        @"proof_request": decryptedPayloadMsg,
        @"source_id": messageId,
        @"state": @3,
        @"their_did": @"",
        @"their_vk": @""
    };
            
    NSDictionary *stringifiableProofRequest = @{
        @"data": stringifiableProofRequestData,
        @"version": decryptedPayloadMsg[@"@type"][@"version"]
    };
}];
```

As a result, the parsed object should have a structure like this: 

### JSON example

```json
 {
        "agent_did": "",
        "agent_vk": "",
        "link_secret_alias": "main",
        "my_did": "",
        "my_vk": "",
        "proof_request": {
            "@topic":{
                "mid": 0,
                "tid": 0,
            },
            "@type": {
                "name": "PROOF_REQUEST",
                "version": "1.0",
            },
            "from_timestamp": null,
            "msg_ref_id": null,
            "proof_request_data": {
                "name": "Basic Info",
                "non_revoked": null,
                "nonce": 220867029780621153091790,
                "requested_attributes": {
                    "Color": {
                        "name": "Color",
                    },
                    "First Name": {
                        "name": "First Name",
                    },
                    "Job Title": {
                        "name": "Job Title",
                    },
                    "Last Name": {
                        "name": "Last Name",
                    },
                    "Number": {
                        "name": "Number",
                    },
                },
                "requested_predicates": {},
                "version": "0.1",
            },
            "thread_id": null,
            "to_timestamp": null,
        },
        "source_id": "OWY3MDd",
        "state": 3,
        "their_did": "",
        "their_vk": "",
    },
    version: "1.0",
}
```
--- 


## 3. Create proof with a message ID

From the proof message object in the previous step you should have <!--[Q11] Who/What actually has the parts?-->all of the necessary parts to generate the proof. The required attributes are: 
 
 - `messageID`
 - `connectionHandle`


### iOS

<!--[Q12] Where is this code visible?-->

```objc
[[sdkAPI] 
    proofCreateWithMsgId: messageId
    withConnectionHandle: (unsigned int)connectionHandle 
    withMsgId: messageId 
    withCompletion: ^(NSError *error, vcx_proof_handle_t proofHandle, NSString *proofRequest) {              
 }
```
### Android

<!--[Q13] Where is this code visible?-->

```java
DisclosedProofApi.proofCreateWithMsgId(sourceId, connectionHandle, messageId).
    exceptionally((t) -> {
        // handle errors
        return null;
    })
    .thenAccept(result -> {
        if (result != null) {
            CreateProofMsgIdResult typedResult = (CreateProofMsgIdResult) result;
            WritableMap vcxProofCreateResult = Arguments.createMap();
            vcxProofCreateResult.putInt("proofHandle", typedResult.proofHandle);
            vcxProofCreateResult.putString("proofRequest", typedResult.proofRequest);
            // handle successful result
        }
    });
```

--- 
## 4. Retrieve proof-matching credentials

Search for attributes <!--[Q14] Who/What searches?--> in the accepted credentials with the same label, and autofill the given attribute with data from the matched credential.

### Example of an autofilled attribute from the credential: 

```json
	{
    "attrs": {
        "First Name": {
            "tails_file": null,
            "credential": {
                "cred_info": {
                    "cred_rev_id": null,
                    "cred_def_id": "AVLv6qDJKU22F22T18XD5x:3:CL:9001:tag1",
                    "schema_id": "AVLv6qDJKU22F22T18XD5x:2:Evernym Staging1539111153570:1.0",
                    "attrs": {
                        "First Name": "Predrag",
                        "Color": "bl",
                        "Number": "1",
                        "Last Name": "Jevtic",
                        "Job Title": "Dev"
                    },
                    "rev_reg_id": null,
                    "referent": "9d5902c7-326a-4761-87c1-bff2c40d940e"
                },
                "interval": null
            }
        }
    }
	}
```

To match some of the proof-request attributes, call <!--[Q15] Who/What calls?--> the libVCX method `proofRequestCredentials`, which will retrieve all previously accepted credentials. 

### Retrieved credentials JSON example:

```json
{
    "attrs": {
        "First Name": {
            "tails_file": null,
            "credential": {
                "cred_info": {
                    "cred_rev_id": null,
                    "cred_def_id": "AVLv6qDJKU22F22T18XD5x:3:CL:9001:tag1",
                    "schema_id": "AVLv6qDJKU22F22T18XD5x:2:Evernym Staging1539111153570:1.0",
                    "attrs": {
                        "First Name": "Predrag",
                        "Color": "bl",
                        "Number": "1",
                        "Last Name": "Jevtic",
                        "Job Title": "Dev"
                    },
                    "rev_reg_id": null,
                    "referent": "9d5902c7-326a-4761-87c1-bff2c40d940e"
                },
                "interval": null
            }
        },
        "Color": {
            "tails_file": null,
            "credential": {
                "cred_info": {
                    "cred_rev_id": null,
                    "cred_def_id": "AVLv6qDJKU22F22T18XD5x:3:CL:9001:tag1",
                    "schema_id": "AVLv6qDJKU22F22T18XD5x:2:Evernym Staging1539111153570:1.0",
                    "attrs": {
                        "First Name": "Predrag",
                        "Color": "bl",
                        "Number": "1",
                        "Last Name": "Jevtic",
                        "Job Title": "Dev"
                    },
                    "rev_reg_id": null,
                    "referent": "9d5902c7-326a-4761-87c1-bff2c40d940e"
                },
                "interval": null
            }
        },
        "Number": {
            "tails_file": null,
            "credential": {
                "cred_info": {
                    "cred_rev_id": null,
                    "cred_def_id": "AVLv6qDJKU22F22T18XD5x:3:CL:9001:tag1",
                    "schema_id": "AVLv6qDJKU22F22T18XD5x:2:Evernym Staging1539111153570:1.0",
                    "attrs": {
                        "First Name": "Predrag",
                        "Color": "bl",
                        "Number": "1",
                        "Last Name": "Jevtic",
                        "Job Title": "Dev"
                    },
                    "rev_reg_id": null,
                    "referent": "9d5902c7-326a-4761-87c1-bff2c40d940e"
                },
                "interval": null
            }
        },
        "Last Name": {
            "tails_file": null,
            "credential": {
                "cred_info": {
                    "cred_rev_id": null,
                    "cred_def_id": "AVLv6qDJKU22F22T18XD5x:3:CL:9001:tag1",
                    "schema_id": "AVLv6qDJKU22F22T18XD5x:2:Evernym Staging1539111153570:1.0",
                    "attrs": {
                        "First Name": "Predrag",
                        "Color": "bl",
                        "Number": "1",
                        "Last Name": "Jevtic",
                        "Job Title": "Dev"
                    },
                    "rev_reg_id": null,
                    "referent": "9d5902c7-326a-4761-87c1-bff2c40d940e"
                },
                "interval": null
            }
        },
        "Job Title": {
            "tails_file": null,
            "credential": {
                "cred_info": {
                    "cred_rev_id": null,
                    "cred_def_id": "AVLv6qDJKU22F22T18XD5x:3:CL:9001:tag1",
                    "schema_id": "AVLv6qDJKU22F22T18XD5x:2:Evernym Staging1539111153570:1.0",
                    "attrs": {
                        "First Name": "Predrag",
                        "Color": "bl",
                        "Number": "1",
                        "Last Name": "Jevtic",
                        "Job Title": "Dev"
                    },
                    "rev_reg_id": null,
                    "referent": "9d5902c7-326a-4761-87c1-bff2c40d940e"
                },
                "interval": null
            }
        }
    }
	}
```

### iOS

<!--[Q16] Where is this code visible?-->
	
```objc 
[[sdkAPI] proofRetrieveCredentials:proofHandle withCompletion:^(NSError *error, NSString *matchingCredentials) {
    // handle error if present 
    // next step if successful
```
### Android

<!--[Q17] Where is this code visible?-->

```java
DisclosedProofApi.proofRetrieveCredentials(proofHandle).exceptionally((t) -> {
        // handle error
        return null;
    }).thenAccept(result -> {
        BridgeUtils.resolveIfValid(promise, result);
    });
```
--- 

## 5. Fill in missing self-attested attributes

All fields that could not be found in any of the accepted credentials must be filled in manually, in most cases using a UI form that the user can fill in by typing or pasting.

The structure of the request-attributes attribute in the proof request will be similar to the previous example but without the additional fields that are populated from the credential: 

### Self-attested attributes example: 
<!--[Q18] JSON?-->
```
	...(rest proof request data)...
	    "requested_attributes": [
	        {
	            "label": "First Name",
	            "key": "First Name",
	            "data": "John"
	        },
	        ...
	    ]
  ...
```

> **Note**: Self-attested or manually filled attributes must be provided separately from automatically filled attributes in the *VCX Proof Generate method*. <!--[Q19] Do they know where to find this?-->

### iOS

<!--[Q20] Where is this code visible?-->

```ObjC
	[libVCX proofGenerate:proofHandle withSelectedCredentials: vcxCreds withSelfAttestedAttrs: @"{}" withCompletion: ^(NSError *error) {
		// ...rest of the flow
	}
```

### Android

<!--[Q21] Where is this code visible?-->

```java
DisclosedProofApi.proofGenerate(proofHandle, selectedCredentials, selfAttestedAttributes)
    .exceptionally((t) -> {
        // handle error 
        return -1;
    })
    .thenAccept(result -> {
        if (result != -1) {
            // handle successful response
                        
        }
    });
```

--- 

## 6. Generate proof 

After all request attributes are filled with data, send <!--[Q22] Who/what sends?-->the request for generating proof from the proof request that was managed in previous steps. Be sure to separate autofilled fields from self-attested fields that are populated manually. <!--[Q23] Who/What does the separating and how is it done?-->

Required attributes are:
- `proofHandle` (from the proof request)
- `selectedCredentialAttributes` (from Step 2)
- `selfAttestedAttributes` (from Step 3)

### iOS

<!--[Q24] Where is this code visible?-->

> Example in LibVCX library for `ObjC`: 

```ObjC
	[[[ConnectMeVcx alloc] init] 
        proofGenerate: proofHandle 
        withSelectedCredentials: selectedCredentials
        withSelfAttestedAttrs: selfAttestedAttributes
        withCompletion: ^(NSError *error) {
	  
	  }
```

### Android

<!--[Q25] Where is this code visible?-->

```java
DisclosedProofApi.proofGenerate(proofHandle, selectedCredentials, selfAttestedAttributes)
    .exceptionally((t) -> {
        // handle error 
        return -1;
    })
    .thenAccept(result -> {
        if (result != -1) {
            // handle successful response
                        
        }
    });
```

---
  
## 7. Sending proof 

After the proof is generated successfully, the only remaining step is to link the generated proof with an established connection. <!--[Q26] Who/What does the linking?-->

Required attributes for this step are: 

- `proofHandle`
- `connectionHandle`  

### iOS

Example in LibVCX library for ObjC:

```ObjC
[[[ConnectMeVcx alloc] init] 
    proofSend: proof_handle
    withConnectionHandle: connection_handle
    withCompletion: ^(NSError *error) {
    // handle error response
    // handle successful response
}
```
### Android

<!--[Q27] Where is this code visible?-->

```java
DisclosedProofApi.proofSend(proofHandle, connectionHandle).exceptionally((t) -> {
    // handle error response
    return -1;
}).thenAccept(result -> {
    if (result != -1) {
        // handle successful response
    }
});
```

---

## Complete Flow in JavaScript: Step by Step 

 This is an example of the full flow in JavaScript: 

   1. Call `downloadMessages('MS-103', null, pwDID)` and filter objects of type `proofReq`.  From there use `decryptedPayload` and the `uid` from the object: 

```javascript
    const MESSAGE_PENDING = 'MS-103';
    // Get messages will have type profReq
    const downloadMessages = await RNIndy.downloadMessages(
        MESSAGE_PENDING,
        null,
        this.props.connection.pwDid,
    );
    
    const msgObject = JSON.parse(downloadMessages)[0]

    //
    const proofReqMsg = msgObject.msgs.find(msg => msg.type === 'proofReq')
    const parsedPayload = proofReqMsg.decryptedPayload
    
    // Step 1 convert decrypted payload from downloadMessages
    const proofRequest = this.convertDecryptedPayloadToSerializedProofRequest(parsedPayload, proofReqMsg.uid )
    // console.log('proofRequest',proofRequest)
    
    // Step 2 get proofHandle
    const proofHandle = await RNIndy.proofDeserialize(proofRequest)
    
    // Step 3 get matchingCredentialsJson
    const matchingCredentialsJson = await RNIndy.proofRetrieveCredentials(proofHandle)
    //{"attrs":{"Account Type":[],"Driver Card":[],"First Name":[]}}

    // Step 4 SKIPPING FOR NOW... if allowing self-attested attributes, get them from the user.  

    // Step 5
    await RNIndy.proofGenerate(proofHandle, JSON.stringify(matchingCredentialsJson), '{}' )

    // Step 6
    const connectionHandle = this.props.connection.connectionHandle
    await RNIndy.proofSend(proofHandle, parseInt(connectionHandle))
```
    
<!--[Q28] Why the break here?-->

```javascript
    convertDecryptedPayloadToSerializedProofRequest = (decryptedPayload,uid ) => {
    let stringifiableProofRequest = {
        data: {
        agent_did: null,
        agent_vk: null,
        link_secret_alias: 'main',
        my_did: null,
        my_vk: null,
        proof: null,
        proof_request: null,
        source_id: uid,
        state: 3,
        their_did: null,
        their_vk: null,
        },
        version: '1.0',
    }
    const parsedPayload = JSON.parse(decryptedPayload)
    const parsedMsg = JSON.parse(parsedPayload['@msg'])
    const parsedType = parsedPayload['@type']
    stringifiableProofRequest.data.proof_request = {
        ...parsedMsg,
        msg_ref_id: uid,
    }
    stringifiableProofRequest.version = parsedType.ver
    return JSON.stringify(stringifiableProofRequest)
    }
```