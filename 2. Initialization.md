# 2. Initializing the Wallet and Cloud Agent

Almost all of the iOS APIs provided by mobile SDK are asynchronous, which means that a completion callback function is required to get the results of the function invocations. This page contains the steps to initialize the wallet and an Evernym Cloud Service cloud agent. Most of these wallet initialization steps are done in the AppDelegate’s `didFinishLaunchingWithOptions` lifecycle method. 

Android API are mostly asynchronous. It uses Java Future API, namely [android-retrofuture](https://github.com/retrostreams/android-retrofuture) implementation. Most of the methods returns `CompletableFuture` objects, that could be used both synchronous and asynchronous ways.

### Introduction
Using the Evernym mobile SDK currently requires that the SDK be connected to and rely on a cloud agent that is hosted and provisioned at Evernym. In the future, this Evernym cloud agent will be replaceable with your own, one from a different vendor but still usable with the Evernym mobile SDK. This agent is used for its store-and-forward services, persistence and availability and ability to push notify to a device or forward via http to the appropriate sponsor. By default, Evernym’s hosted cloud services are locked down. In order for your mobile SDK instance to prove that it has permission to provision a new hosted cloud agent (one unique cloud agent per installation of your mobile app), you must provide a token.

<!--![](https://github.com/evernym/mobile-starter/blob/master/wiki-images/InitializingWalletConnectMe.png)This illustration is not helpful because it is not a decision tree-->

### Definitions
- Sponsor \
   Application owner using the mobile SDK to `Sponsor` individual app installs e.g. Example Credit Union is the `Sponsor` using the Evernym mobile SDK inside their own mobile app. Also `Sponsor` should have backend server that will perform token issuing.
>   **Example** Credit Union is the Sponsor using the Evernym mobile SDK inside their own mobile app.

    
- Sponsee \
    Individual App install.
>   **Example**  The app on Ryan’s phone is a Sponsee. He is an Example Credit Union member installing Example CU’s mobile app (`Sponsor`)  

- Evernym Cloud Service \
    Evernym hosted cloud service which facilitates provisioning and management of cloud agents - Evernym tokenizer service, provisioning protocol, agent management for all other protocols

- Provision Token \
    This token is provided by a `Sponsor` to enable provisioning of an Evernym hosted cloud agent.
    ```json
     {
       "sponseeId":     String,
       "sponsorId":     String,
       "nonce":         String,
       "timestamp":     String,
       "sig":           String,
       "sponsorVerKey": String,
   
     } 
    ```

    * `sponseeId`:
     An identifier a `Sponsor` uses to identify/reference the `Sponsee`. This can be a customer id used to identify the `Sponsee` in the `Sponsor's` back end database. In other words, this is an ID of a app user.
    * `sponsorId`: 
     The persistent id given to the `Sponsor` when the `Sponsor` works with Evernym TE to register the configuration.
    * `nonce`:
    Randomly generated string. Used as one-time security token during registration. \
    **Example**. `random.number.toString()`
    * `timestamp`:
    An RFC 3339 and ISO 8601 date and time string such as `1996-12-19T16:39:57-08:00`.
    * `sig`:
    The `Sponsor` create a string by concatenating in this order `nonce + timeStamp + sponseeId + sponsorId` then signs the resulting string, then encodes it to a base64 encoded string. The `Sponsor` uses the signing keys associated with the `Evernym Cloud Service` registered verkey to perform the signature. 
    **Example** Base64Encode(Sign(nonce + timeStamp + sponseeId + sponsorId))
    * `sponsorVerKey`: 
    `Sponsor's` verkey associated with the signing keys. `Sponsor` can register multiple keys so this helps identify which key to use. This key is not used unless a corresponding one is found in the configuration.

Simple server performing provision token signing and provision token generation could be found [here](./simple-sponsor).

- VCX Config: The list of options can be set in the config JSON passed to `vcx_get_provision_token` and `vcx_provision_agent_with_token` functions
    can be found in [the document](./Configuration.md).

### Sponsor Registration with Evernym's Cloud Service
- In order to register as a `Sponsor`, contact `support@evernym.com`.
- Registration requires the `Sponsor` (you) to provide these attributes to Evernym. Please include them in your email to support@evernym.com: 
    ```json
      {
        "name": "String",
        "id": "String",
        "keys": [{"verKey":"VK"}],
        "endpoint": "String",
        "active": boolean 
      }
    ```
    `name`: The name of the `Sponsor` who endorses the provisioning . \
    `id`: An ID which will not change. Keys cannot be used because of rotation possibilities. \
    `keys`: VerKey associated with the signing of the token and used to verify a `Sponsee's` provision token. 
     - The signing keys (including the verkey shared with Evernym's Cloud Service) can be generated using this simple tool: `https://github.com/sovrin-foundation/launch/raw/master/sovrin-keygen.zip` 
     - The Private keys need to be stored in a safe place under control of the `Sponsor` (you). 
     - The public verkey will be shared with Evernym for signature validation.
     
    `endpoint`: `Sponsor's` URL that Evernym Cloud Service should forward `Sponsee` messages to. This is how you will add push notifications to your mobile app. Evernym does not host a push notification service for the mobile SDK, you must create and manage your own. Evernym cloud agents will forward messages to this endpoint for you to push notify to your app. \
    `active`: If the `Sponsor` has an active status with Evernym's Cloud Service 
### Mobile SDK - 3rd party apps (`Sponsee`)
1. Obtaining Provision Token
    - An app will have to communicate with its `Sponsor` to receive a `token`. 
    - This `token` will contain a signature generated by the `Sponsor` to ensure the provisioning application (`Sponsee`) has authorization to do so.
    - It also contains a timestamp. If the token isn’t delivered to Evernym's Cloud Service in a predefined time frame, the token will be invalid. The `Sponsee` will need to request another `token` from its `Sponsor`.
    - If for whatever reason provisioning fails, the `Sponsee` should request a new `token` from its `Sponsor` and attempt provisioning again. 
2. Provisioning
    - **** Same steps as previous provision except that the token needs to be included. 
    - If a wallet is already configured before the provision, this wallet will be used. If not, a new one will be created.
    - The configuration returned from this api will be the input for `vcx_init`. At this point, the app will be provisioned on Evernym's Cloud Service with a cloud agent and will have a local wallet initialized but NOT open. `Vcx_init` will open the wallet.

3. Receiving Future Messages
    - `Sponsee` will need to call update_com_method \
      `id`: String - `Sponsee's` Id, \
      `type`: Int - Com Method Type (ALWAYS `3` for forwarding), \
      `value`: String 
      - `Sponsee` messages are forwarded to the `Sponsor`. `value` will be the whatever information the Sponsor's back-end will need to deliver that message to the `Sponsee`.  
      - When Evernym's Cloud Service receives a message for this entity (through provisioned cloud agent), the cloud agent will forward the message to the Sponsor. The `Sponsor` will the deliver the message to the `Sponsee` with whatever mechanism it already uses to communicate with its customer.  
    - The cloud agent will forward messages to the `Sponsor's` back-end vi http. No A2A encryption will be added. The http message will include:
        1. `msgId`:  This is the id that the `Sponsee` will use to actually download the message
        2. `sponseeDetails`: `Sponsee` messages are forwarded to the `Sponsor`. This will be the whatever information the `Sponsor's` back-end will need to deliver that message to the `Sponsee`.  
        3. `relationshipDid` - My DID - the specific relationship I'm interacting on.  
        4. `metaData` - message type and sender's name. This is used mostly to display the message for the `Sponsee`. These values are optional from the sender's perspective.
        ```json 
       {
         msgId: String,
         sponseeDetails: String, 
         relationshipDid: String,
         metaData: {
           msgType: String,
           msgSenderName: String,
         }
       } 
        ```
    - The `Sponsor` will then push notify the `Sponsee` informing that a message is available and ready to be downloaded from the `Sponsee's` cloud agent. 

### CMe Sponsee
1. Obtaining Provision Token
    1. A wallet will be necessary to obtain an Evernym signed provision token. If a wallet is already created before the token request, this wallet will be used. If not, a new one will be created. This wallet can be deleted after because the permanent keys are inserted during the provisioning process. At a minimum the wallet needs to be closed (`vcx_shutdown(true)`)
    2. `vcx_get_provision_token` takes a configuration: 
        ```json 
         {
            "vcx_config": Vcx Config (defined above),         
            "sponseeId": String,
            "sponsorId": String,
            "com_method": {
                "type": u32, // 1 is the only supported type. 1 is for push notifications.
                "id": String,
                "value": String, // this is the actual push notification address
            }
         }
        ```
        **Example**: `{"type": 1,"id":"123","value":"FCM:Value"}`
      
   3.  Authentication: The approach that Evernym's Cloud Service is taking for authentication is that if a token request comes in, the response will be sent via push notification to only CMe. No other apps will receive this token because of the firebase key.
   
        - A better authentication approach will happen eventually. 
        - If the token is not received, delete the wallet <shutdown(true)> and ask for a new token. 
        
2. Provisioning
    1. Deleting the wallet (or at least closing it) should happen before re-attempting this
        - delete wallet: vcx_shutdown(true) 
        - close wallet: vcx_shutdown(false) 

    2. If a wallet is already configured before the provision, this wallet will be used. If not, a new one will be created.
    3. **** Same steps as previous provision except that the token needs to be included. 
    4. The configuration returned from this api will be what is passed into vcx_init. At this point, the app will be provisioned on Evernym's Cloud Service with a cloud agent and will have a local wallet initialized but NOT open. Vcx_init will open the wallet.
    5. Update com method
    
3. Receiving Future Messages
    - update com method

### iOS
Refer to [AppDelegate.m](mobile-starter-master/ios/CMeSdkObjc/CMeSdkObjc/AppDelegate.m).

### Android
Refer to [ConnectMeVcx#init()](Examples/android/CMeSdkJava/lib/src/main/java/me/connect/sdk/java/ConnectMeVcx.java#L65). 
1.  libVcx uses `slf4j` logging library. \
    Sample of configuration to store libVcx logs in specified file could be found [here](Examples/android/CMeSdkJava/lib/src/main/java/me/connect/sdk/java/ConnectMeVcx.java#L114).\
    For additional information about logging configuration see [slf4j documentation](http://www.slf4j.org/docs.html).

2. Genesis transaction pool used to configure network could be found [here](Examples/android/CMeSdkJava/app/src/main/java/me/connect/sdk/java/sample/Constants.java#L5). This configuration targets *production* network.\ 
    In case your app works with other network, corresponding genesis transaction files for different environment could be found
[here](https://github.com/sovrin-foundation/sovrin/tree/master/sovrin). 
    This files should be saved on filesystem and be accessible to libVcx. For sample, [ConnectMeVcx#writeGenesisFile()](Examples/android/CMeSdkJava/lib/src/main/java/me/connect/sdk/java/ConnectMeVcx.java#L150).

3. On first init (if you don't have populated JSON config) following steps shoud be performed:

    1. Create directory where wallet will be located.

    2. Generate wallet key. See [ConnectMeVcx#createWalletKey()](Examples/android/CMeSdkJava/lib/src/main/java/me/connect/sdk/java/ConnectMeVcx.java#L186).

    3. Prepare agency configuration JSON using wallet name, key and wallet directory path (see [config sample](#config-sample)).

    4. Call `UtilsApi#vcxAgentProvisionAsync()` with prepared config to fill necessary fields.

    5. Add additional fields to resulting JSON (see [ConnectMeVcx#populateConfig()](Examples/android/CMeSdkJava/lib/src/main/java/me/connect/sdk/java/ConnectMeVcx.java#L138)) and store resulting JSON string for latter usage. On second and other inits that JSON will be used to initialize libVcx. This JSON should be securely stored.
    

4. Call `VcxApi#initSovToken()` to initialize libVcx. In case return code is not `0` , you should call `VcxApi#vcxInitWithConfig(config)` with config created on step _#3.5_


> **NOTE:** If the initialization of the wallet does not work after you followed these steps, please contact Evernym. If you had to do extra steps to get it working, please also let us know what you had to do so that we can update this document.


## Selecting the Ledger and Cloud Service

#### Ledger

If you want to use a different Ledger, you *must* change to the corresponding Evernym Cloud Service as described in the *Evernym Cloud Service* section below.

1. Change the contents of the `poolTxnGenesis` variable in the above code. <!--[Q4] Do you mean the files above that they "refer to"?-->Evernym has several active Ledger instances that we use for different scenarios: 
`development
sandbox
staging
demo
qatest1
qatest2
devrc
qarc
devteam1
devteam2
devteam2
prod`

   * You can find an older configuration for some of these ledgers [here](https://github.com/sovrin-foundation/connector-app/blob/master/app/store/config-store.js).
  
   * Search for `server_environment` to see some of these instances.

3. Use the `poolConfig:` setting in the particular environment to set the `poolTxnGenesis` variable to the value of the `poolConfig:` setting. If you  want to use a different Ledger other than `demo`, which is what the above code uses, then please let us know. <!--[Q5] Do they need to ask Evernym for permission or instructions to use a different Ledger, or do they talk to us if they want to use a different Ledger than in the list in Step 1?-->

#### Evernym Cloud Service

If you choose to use a different Ledger then you *must* change to the corresponding Evernym Cloud Service and vice-versa. 

* To use a different Evernym Cloud Service, change the contents of the `agencyConfig` variable in the above code. 

* For every different Ledger configuration there is a corresponding Evernym Cloud Service configuration. These configuration settings can be seen in the same `config-store.js` code that was linked in the Ledger section above. 

* You will need to change `agency_did`, `agency_url`, and `agency_verkey` in the code above to use a different Evernym Cloud Service for the corresponding Ledger.

<a id="config-sample"></a>

### Agency config sample

```json
{
    // These fields are used for agency configuration
    "agency_url": "http://agency.evernym.com", // URL of agency to use
    "agency_did": "DwXzE7GdE5DNfsrRXJChSD", // DID of agency
    "agency_verkey": "844sJfb2snyeEugKvpY7Y4jZJk9LT6BnS6bnuKoiqbip", // Verification key of the agency

    //These fields are used for wallet configuration
    "wallet_name": "name", // Name of the wallet
    "wallet_key": "key", // Wallet key
    "storage_config": { // Wallet storage config
        "path": "/path/to/wallet", // Path to the wallet directory
    }
}
```

### Android

Android sample app contains ready for use genesis pool configurations available in [raw resource directory](Examples/android/CMeSdkJava/app/src/main/res/raw).



## Push notifications setup

For in more depth information how push notifications works in one of the platforms, you can read official documentation sections for: 
   
   - Android: [https://developer.android.com/guide/topics/ui/notifiers/notifications](https://developer.android.com/guide/topics/ui/notifiers/notifications)
   - iOS: https://developer.apple.com/documentation/usernotifications/ 

From Vcx and cloud agent perspective, you will need to link received **push notification token** you received on your device with your cloud agent in Vcx, so notifications will be sent to correct device. 

We also recommend using Firebase Cloud Messaging, since it's provide universal configuration for both platforms (iOS and Android): https://firebase.google.com/docs/cloud-messaging/android/client. 

How to link your push notification with VCX cloud agent? 

For the moment, sending push notifications should happen from user's cloud agent (which will receive notification from Evernym cloud agent) so all mobile device tokens are stored on your side, safely and securely.

We are working also on improving service related to push notifications, we should have more details soon. 

In meantime, you can use method ```downloadMessages``` in ObjC or ```UtilsApi.vcxGetMessages``` in Java, for pulling all messages waiting on cloud agent. Parameters for this method are as follows:
```
messageStatus: optional, comma separated - query for messages with the specified status.
  Statuses:
   MS-101 - Created
   MS-102 - Sent
   MS-103 - Received
   MS-104 - Accepted
   MS-105 - Rejected
   MS-106 - Reviewed

uids: optional, comma separated - query for messages with the specified uids.

pwdids: optional, comma separated - DID's pointing to specific connection.
```

This returns a JSON object which can be parsed into an array of messages, each of which contains a JSON object that itself can be parsed into the message payload.

 ObjC
```objc
[appDelegate.sdkApi downloadMessages:@"MS-103" uid_s:nil pwdids:pw_did completion:^(NSError *error, NSString *messages) {
}
```



<!-- After wallet initialization Vcx with specific configuration (steps from above), you just need to call a method **updateAgentInfo** and provide details of your deviceID and push notification token, in this format: 

```
   { uniqueId: '{deviceID}', pushToken: 'FCM:{pushToken}' }
``` -->

<!-- ### iOS: 

> In same file with wallet initialization steps, eg. AppDelegate.m 

```ObjectiveC
[appDelegate.sdkApi agentUpdateInfo:pushNotifConfig completion:^(NSError *error) {
   if (error != nil && error.code != 0)
   {
         NSString *indyErrorCode = [NSString stringWithFormat:@"%ld", (long)error.code];
         NSLog(@"3) Value of indyErrorCode is: %@", indyErrorCode);
   } else {
         NSLog(@"Updated the push notification token to: %@", tokenString);
   }
}];
``` -->

<!-- ### Android: 

> In same file with wallet initialization steps, eg. ConnectMeVCX.java -->

<!-- ```java
UtilsApi.vcxUpdateAgentInfo(config).exceptionally((t) -> {
   promise.reject("FutureException", t.getMessage());
      return -1;
   }).thenAccept(result -> {
   if (result != -1) {
      BridgeUtils.resolveIfValid(promise, result);
   }
});
``` -->
